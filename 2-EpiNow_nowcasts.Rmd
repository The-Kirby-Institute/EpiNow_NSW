# Now casting script for running EpiNow2 on NSW COVID case data
# =============================================================

```{r Set-up}
# Open as a project (setting working directory to source and restarting R)

# Packages
require(EpiNow2, quietly = TRUE)
require(tidyverse, quietly = TRUE)
require(lubridate, quietly = TRUE)
require(future, quietly = TRUE)

options(dplyr.summarise.inform=FALSE)

# Functions 
source("code/LoadData.R")
source("code/GetCases.R")
source("code/SpecifyRegions.R")
source("code/RegionalSummary.R")
source("code/regional_summary_NSW.R")
source("code/plot_summary_NSW.R")
source("code/RegionsCumulativeReports.R")
source("code/Functions.R")
```

```{r User inputs}
# Chunk where user enters all the input options for running EpiNow2

dateRun <- NULL # Run to this date: NULL = last date in data file
startDate <- "2021-08-01" # Filter to after this date (speeds things up) 

# Specify where the case data is coming from see LoadData() function for 
# details. 
dataOption <- "nsw_website" # "nsw_website" or "file"
delayOption <- "nsw_data" # nsw_data (default), "testing", "international"

# Specify which regions will be inputed into EpiNow and where the results 
# will be stored in the results/ folder. These can be entered manually
# or via the use of the SpecifyRegions() function. 

postcodeRun <- TRUE

if (postcodeRun) {
  specificRegions <- SpecifyRegions("postcode")[[1]]
  resultsFolder <- SpecifyRegions("postcode")[[2]]
} else {
  specificRegions <- SpecifyRegions("all")[[1]]
  specificRegions <- c("NSW", "Greater Sydney") #, "Northern NSW",
  #   "Western NSW", "Southern NSW")
  resultsFolder <- SpecifyRegions("all")[[2]] 
}

# Produce summary comparison results for regions, LGAs, and postcodes
summariseResults <- TRUE

```

```{r Sort out case data}
# Load raw case data 
print("Retrieving raw cases data...")
nsw_raw_cases <- LoadData(dataOption)

# Save website data for later
if (dataOption == "nsw_website") {
  write_csv(nsw_raw_cases, file = file.path("data", 
    paste0("NSW_Health_Website_Data-", Sys.Date())))
}

# Get cases we want 
print("Getting cases...")

# Load postcode and locality file

casesAll <- GetCases(nsw_raw_cases, dataOption, startDate) 


if (postcodeRun) {
  cases <- casesAll[[2]] 
  
  dateCases <- max(cases$date)
  
  postcodes <- read_csv(paste0("data/postcode_suburb_name-", 
    dateCases, ".csv"), show_col_types = FALSE) %>%
    select(postcode = Postcode, name = ...4) %>% 
    mutate(region = as.character(postcode))
  
  specificRegions <- postcodes$postcode
  
} else {
  cases <- casesAll[[1]]
  
  dateCases <- max(cases$date)
}   

# Filter out dates we don't need
if(!is.null(dateRun)) {
  cases <- cases %>% 
    filter(date <= dateRun)
}

# Filter out regions we are not interested in
if (specificRegions[1] != "all") {
  cases <- cases %>%
    filter(region %in% specificRegions)
} 

if (postcodeRun) {
  # Convert postcode numbers to names
  cases <- left_join(cases, postcodes, by = "region") %>%
    select(date, confirm, postcode, region = name)
}
```

```{r Set-up outputs}
# This chunk sets up cases, variables, and output details for EpiNow 
aggregateRegions <- c("NSW", "Greater Sydney", "Northern NSW",
  "Western NSW", "Southern NSW", "All Regional NSW")

# Separate out LGA and aggregate regions if not postcode run
if (!postcodeRun) {
  regionCases <- filter(cases, region %in% aggregateRegions)
  lgaCases <- filter(cases, !(region %in% aggregateRegions))
  
  multiRegions <- unique(regionCases$region)
  multiRegionRun <- ifelse(length(multiRegions) > 1, TRUE, FALSE)
  
  multiLGAs <- unique(lgaCases$region)
  multiLGArun <- ifelse(length(multiLGAs) > 1, TRUE, FALSE)
} else {
  postcodeCases <- cases
}

dir.create(file.path("results", resultsFolder), showWarnings = FALSE)
```

```{r Load EpiNow delay parameters and rt prior}
print("Loading delay definitions...")

if (delayOption == "nsw_data") {
  # Load delay_defs fitted from local NSW data. This needs to be generated
  # separately using the EpiNow_update_delay.R script.
  reporting_delay <- readRDS("data/local_delays.rds")
} else if (delayOption == "international") {
  # Out of date delay estimate from international sources
  reporting_delay <- readRDS("data/international_delays.rds")
} else if (delayOption == "testing") {
  # Basic set-up for testing purposes
  reporting_delay <- list(mean = EpiNow2::convert_to_logmean(4, 1),
    mean_sd = 0.1, sd = EpiNow2::convert_to_logsd(4, 1),
    sd_sd = 0.1, max = 15)
} else {
  stop("Unknown reporting delay option")
}

# Other delays from the literature
generation_time <- EpiNow2::get_generation_time(disease = "SARS-CoV-2", 
  source = "ganyani")
incubation_period <- EpiNow2::get_incubation_period(disease = "SARS-CoV-2", 
  source = "lauer")

# Specify prior for RT. Currently assumed to be low given the presence of
# restrictions with some LGAs having no cases. We use this assumed prior 
# to prevent EpiNow forecasting massive increases in cases when numbers
# are small.  
rtPrior <- rt_opts(prior = list(mean = 1, sd = 0.5))
```

```{r Set-up simulations}
print("Setting up EpiNow...")
# Use future package to run things in parallel

options(future.fork.enable = TRUE)
future::plan("multiprocess", workers = round(future::availableCores() / 2))
# ncores <- round(future::availableCores() / 2)
```

```{r Run EpiNow}
# Initialize outputs for aggregate regions, LGAs, and postcodes
regionEstimates <- NULL
lgaEstimates <- NULL
postcodeEstimates <- NULL

print("Running EpiNow...")

if (!postcodeRun) {
  # Run EpiNow for aggregate regions
  if (multiRegionRun) {
    # More than one aggregate region so run regional version of EpiNow
    print("Generating multiple aggregate region estimates...")
    regionEstimates <- EpiNow2::regional_epinow(reported_cases = regionCases, 
      generation_time = generation_time,
      delays = delay_opts(incubation_period, reporting_delay),
      rt = rtPrior,
      stan = stan_opts(),
      target_folder = file.path("results", resultsFolder),
      logs = file.path("logs", Sys.Date()),
      return_output = TRUE, 
      verbose = TRUE)
    
    # Produce aggregate region summary results.
    # Stored in ./results/`resultsFolder`/Regions-summary/ 
    if (summariseResults) {
      print("Producing aggregate region summary ...")
      RegionalSummary(regionEstimates, resultsFolder, "Regions-summary", dateCases) 
    }
    
    # Run function to save CSV file of key indicators for each region
    for (region in names(regionEstimates$regional)) {
      keyEstimates <- GetKeyEstimates(regionEstimates, multiRegionRun, region)
      
      SaveAllIndicators(keyEstimates, 
        file.path("results", file.path(resultsFolder, region)),
        dateCases)
      SaveAllIndicators(keyEstimates, 
        file.path("results", file.path(resultsFolder, region)), 
        "latest")
    }
    
  } else {
    # 0 or 1 regions in multiRegions
    if (nrow(regionCases) != 0) {
      # Single region so run normal EpiNow
      print("Generating Single LGA estimates...")
      regionEstimates <- EpiNow2::epinow(
        # Need to remove region column from cases for this to run
        reported_cases = dplyr::select(regionCases, -region),
        generation_time = generation_time,
        delays = delay_opts(incubation_period, reporting_delay),
        rt = rtPrior,
        stan = stan_opts(),
        target_folder = file.path("results", resultsFolder,
          lgaRegions),
        logs = file.path("logs", Sys.Date()),
        return_output = TRUE, 
        verbose = TRUE)
      
      # Run function to save CSV file of key indicators 
      keyEstimates <- GetKeyEstimates(regionEstimates, FALSE)
      
      SaveAllIndicators(keyEstimates, 
        file.path("results", resultsFolder, multiRegions),
        dateCases)
      SaveAllIndicators(keyEstimates, 
        file.path("results", resultsFolder, multiRegions), 
        "latest")
    } 
  }
  
  # Run EpiNow for LGAs
  if (multiLGArun) {
    # More than one LGA so run regional version of EpiNow
    print("Generating Multiple LGA estimates...")
    lgaEstimates <- EpiNow2::regional_epinow(reported_cases = lgaCases, 
      generation_time = generation_time,
      delays = delay_opts(incubation_period, reporting_delay),
      rt = rtPrior,
      stan = stan_opts(),
      target_folder = file.path("results", resultsFolder),
      logs = file.path("logs", Sys.Date()),
      return_output = TRUE, 
      verbose = TRUE)
    
    # Produce LGA summary results.
    # Stored in ./results/`resultsFolder`/LGA-summary/ 
    if (summariseResults) {
      
      print("Producing LGA summary ...")
      RegionalSummary(lgaEstimates, resultsFolder, "LGA-summary", dateCases) 
    }
    
    # Run function to save CSV file of key indicators for each region
    for (region in names(lgaEstimates$regional)) {
      keyEstimates <- GetKeyEstimates(lgaEstimates, multiLGArun, region)
      
      SaveAllIndicators(keyEstimates, 
        file.path("results", file.path(resultsFolder, region)),
        dateCases)
      SaveAllIndicators(keyEstimates, 
        file.path("results", file.path(resultsFolder, region)), 
        "latest")
    }
    
  } else {
    # 0 or 1 LGAs in lgaRegions
    if (nrow(lgaCases) != 0) {
      # Single LGA so run normal EpiNow
      print("Generating Single LGA estimates...")
      lgaEstimates <- EpiNow2::epinow(
        # Need to remove region column from cases for this to run
        reported_cases = dplyr::select(lgaCases, -region),
        generation_time = generation_time,
        delays = delay_opts(incubation_period, reporting_delay),
        rt = rtPrior,
        stan = stan_opts(),
        target_folder = file.path("results", resultsFolder,
          lgaRegions),
        logs = file.path("logs", Sys.Date()),
        return_output = TRUE, 
        verbose = TRUE)
      
      # Run function to save CSV file of key indicators 
      keyEstimates <- GetKeyEstimates(lgaEstimates, FALSE)
      
      SaveAllIndicators(keyEstimates, 
        file.path("results", resultsFolder, lgaRegions),
        dateCases)
      SaveAllIndicators(keyEstimates, 
        file.path("results", resultsFolder, lgaRegions), 
        "latest")
    } 
  }
} else {
   print("Generating Postcode estimates...")
    postcodeEstimates <- EpiNow2::regional_epinow(reported_cases = postcodeCases, 
      generation_time = generation_time,
      delays = delay_opts(incubation_period, reporting_delay),
      rt = rtPrior,
      stan = stan_opts(),
      target_folder = file.path("results", resultsFolder),
      logs = file.path("logs", Sys.Date()),
      return_output = TRUE, 
      verbose = TRUE)
    
    # Produce LGA summary results.
    # Stored in ./results/`resultsFolder`/LGA-summary/ 
    if (summariseResults) {
      
      print("Producing postcodes summary ...")
      RegionalSummary(postcodeEstimates, resultsFolder, "Postcode-summary", dateCases) 
    }
    
    # Run function to save CSV file of key indicators for each region
    for (region in names(postcodeEstimates$regional)) {
      keyEstimates <- GetKeyEstimates(postcodeEstimates, TRUE, region)
      
      SaveAllIndicators(keyEstimates, 
        file.path("results", file.path(resultsFolder, region)),
        dateCases)
      SaveAllIndicators(keyEstimates, 
        file.path("results", file.path(resultsFolder, region)), 
        "latest")
    }
}

print("Tidying up...")
# Save everything in the results folder just in case
save(startDate, dateRun, specificRegions, dataOption, 
  delayOption, cases, regionEstimates, lgaEstimates, postcodeEstimates, 
  resultsFolder, generation_time, incubation_period, reporting_delay,
  file = file.path("results", resultsFolder, paste0("Epinow_results-", 
    format(Sys.time(), "%Y-%m-%d_%H-%M-%S"), ".rds")))
```

```{r Summarise results}
## Useful Commands for looking at individual region results
# > summary(estimates)
# > plot(estimates)
# > summary(estimates, type = "parameters", params = "R")
```

