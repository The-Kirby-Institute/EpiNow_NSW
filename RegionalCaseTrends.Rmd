# Script for exploring trends in specific regions and areas
# =========================================================

```{r Set-up}
# Open as a project (setting working directory to source and restarting R)

# Packages
require(tidyverse, quietly = TRUE)
require(lubridate, quietly = TRUE)
require(segmented, quietly = TRUE)

# Functions 
source("code/GetCases.R")
source("code/LoadData.R")
source("code/SpecifyRegions.R")
source("code/PlotOptions.R")
source("code/Functions.R")

```

```{r User inputs}
# Retrieve cases
dataOption <- "nsw_website" 
nsw_raw_cases <- LoadData(dataOption)

# Case dates
startDate <- "2021-06-01" # Filter to after this date 
dateRun <- NULL # Filter to before this date: NULL = last date in data file

# Specify region
regionLevel <- "LGA" # "NSW", "Sydney",  or "LGA"
regionName <- "Burwood (A)"   # If not "NSW" or "Sydney" then single LGA
                              # E.g. "Fairfield (C)", "Sutherland Shire (A)"
# unique(sort(nsw_raw_cases$lga_name19)) 
```

```{r Get region cases data}
# Will produce error if there are no cases
cases <- GetCases(nsw_raw_cases, dataOption, regionLevel, startDate, 
  regions = regionName) %>%
  select(-region) %>%
  # Fill in missing dates with zeros
  left_join(tibble(date = as_date(ymd(min(.$date)):ymd(max(.$date))),
    confirm = 0), ., by = "date") %>%
  replace_na(list(confirm.y = 0)) %>%
  mutate(confirm = confirm.x + confirm.y) %>%
  # tidy up
  arrange(date) %>%
  mutate(day = 1:nrow(.)) %>%
  select(date, day, confirm)
```

```{r Plot of cases}
plotTitle <- ifelse(regionLevel == "LGA", regionName, regionLevel)
regionPlot <- casesRegionPlot(cases, plotTitle)

regionPlot
```

```{r Simple overall trends}
trendCases <- glm(confirm ~ day, data = cases, family = "poisson")
coeff <- exp(coef(trendCases)[2])
p_value <- summary(trendCases)$coefficients["day", "Pr(>|z|)"]
interval <- exp(confint(trendCases, "day", type = "Wald"))

# Add overall trend to plot
regionPlotTrend <- regionPlot +
  geom_line(aes(y = fitted(trendCases)), 
    colour = "black")

regionPlotTrend

```

```{r Segmented trends}
# Initial breakpoint estimates - use trial and error based on visual 
# inspection and test for sensitivity by varying the initial guess of the 
# breakpoint to see if there is any change in the fitted curve. 
breakPoints <- list("single" = mean(cases$day), 
  "double" = c(quantile(cases$day, 0.25), quantile(cases$day, 0.75)))

# Fit segmented model
segModel1 <- segmented(trendCases, seg.Z = ~day, 
  psi = list(day = breakPoints$single))

# segModel2 <- segmented(trendCases, seg.Z = ~day, 
#   psi = list(day = breakPoints$double))

ymax <-1.1*max(cases$confirm)

segPlot <- ggplot(data = cases, 
  aes(x = date, y = confirm)) + 
  geom_line(aes(color = "cases")) + 
  geom_point(color = "red") +
  geom_line(aes(y = fitted(trendCases), colour = "overall")) +
  geom_line(aes(y = fitted(segModel1), colour = "segment")) + 
  # expand_limits(y = c(0, ymax)) +
  scale_colour_manual("", values = c("red", "black", "blue"),
    limits = c("cases", "overall", "segment"),
    labels = c("Cases", "Overall model",
      "Segmented model")) +
  ylab("Daily cases") + xlab("Date") +  
  PlotOptions() +
  geom_vline(xintercept = cases$date[1] + (segModel1$psi[2]-1), 
      linetype = "dashed",
      colour = "blue")

segPlot

```

```{r NLS fit EXPERIMENTAL}
# Experimental chunk looking at NLS fits using a function with 
# exponential increase and decay. 
# NOT WORKING YET. 

# Main model
FitModel <- function(x, a, g, d, k) {
  return(k * a * exp((g-d) * x) / ((k - a) +
      a*exp(g * x)))
}

# Time to peak in model
TP <- function(a, g, d, k) {
  return((1/g) * log((g-d)*(k-a)/(d*a)))
}

# To find good initial conditions requires guessing and checking 
regionPlot + 
  geom_line(aes(y = FitModel(1:51, 0.1, 0.49, 0.055, 200)), 
    colour = "dark green")

# Now run nls() to produce a non-linear model.
fitModel <- nls(confirm ~ FitModel(day, a, g, d, k), data = cases, 
  start = list(a = 0.1, g = 0.49, d = 0.055, k = 200),
  control = nls.control(maxiter = 1000))



```


